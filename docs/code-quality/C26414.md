---
title: C26414
ms.date: 11/15/2017
ms.prod: visual-studio-dev15
ms.technology: vs-ide-code-analysis
ms.topic: conceptual
f1_keywords:
- C26414
helpviewer_keywords:
- C26414
ms.assetid: dd875d0c-6752-4491-a533-3e8831795fbc
author: mikeblome
ms.author: mblome
manager: douge
ms.workload:
- multiple
ms.openlocfilehash: c843b67cdea04ba7458ae1852e7f7d7db7bdf380
ms.sourcegitcommit: 240c8b34e80952d00e90c52dcb1a077b9aff47f6
ms.translationtype: MT
ms.contentlocale: tr-TR
ms.lasthandoff: 10/23/2018
ms.locfileid: "49822938"
---
# <a name="c26414-resetlocalsmartptr"></a>C26414 RESET_LOCAL_SMART_PTR
"Taşıyın, kopyalayın, yeniden atama veya yerel bir akıllı işaretçiyi Sıfırla."

**C++ temel yönergeleri**: R.5: kapsamlı nesneleri tercih edin, yığın-ayırmayın yok

Akıllı işaretçiler dinamik kaynak yönetimi için kullanışlıdır ancak her zaman gerekli değildir. Örneğin, yerel bir dinamik buffer oluşturulurken kolayca olabilir (bazı durumlarda daha fazla end verimli bir şekilde) standart kapsayıcılar tarafından yönetilen. Tek nesneler için dinamik ayırma yapmanız gereksiz olabilir (örneğin, bu tür nesneleri hiçbir zaman oluşturucu işlevleri daha uzun sürmesi) ve yerel değişkenlerle değiştirilir. Senaryo sahipliğini, değiştirilmesi gerektiğinde akıllı işaretçiler kullanışlı hale yani dinamik bir kaynağın birden çok kez veya birden çok yol yeniden atama. Bu da burada kaynakları dış koddan elde edilir ve akıllı işaretçiler kaynağın ömrü genişletmek için kullanılan servis taleplerini içerir.

## <a name="remarks"></a>Açıklamalar
- Standart std::unique_pointer ve std::shared_pointer şablonlar ek olarak, bu onay, büyük olasılıkla akıllı işaretçiler amaçlara yönelik olduğunu kullanıcı tanımlı türleri tanır. Bu türler, aşağıdaki işlemleri tanımlamak için beklenir:
  - aşırı başvuru veya üye erişim işleçleri, genel ve silindiği; işaretlenmemiş
  - Silinmiş varsayılan olarak ne ortak yıkıcısı de. Bu açıkça boş tanımlanan yok ediciler içerir.
  - Microsoft::wrl:: comptr türü paylaşılan bir işaretçi davranır, ancak genellikle COM ömrü Yönetimi tarafından etkilenen oldukça belirli senaryolarda kullanılır. Aşırı gürültüsünü önlemek için bu tür filtrenin dışında kaldı.
  - <a name="this-check-looks-for-explicit-local-allocations-assigned-to-smart-pointers-to-identify-if-scoped-variables-could-word-as-an-alternative-in-addition-to-direct-calls-to-operator-new-special-functions-like-stdmakeunique-and-stdmakeshared-are-also-interpreted-as-direct-allocations"></a>Bu onay, kapsamlı değişkenler alternatif olarak word tanımlamak için akıllı işaretçiler için atanan açık yerel ayırmaları arar. New işleci, doğrudan çağrıları yanı sıra std::make_unique ve std::make_shared gibi özel işlevler de doğrudan ayırmaları yorumlanır.
    -
    ## <a name="example"></a>Örnek
    dinamik arabelleği

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::make_unique<char[]>(f.size()); // C26414
    f.unpack(buffer.get());
    // ...
}
```
## <a name="example"></a>Örnek
Dinamik arabellek – kapsayıcı tarafından değiştirildi

```cpp
void unpack_and_send(const frame &f)
{
    auto buffer = std::vector<char>(f.size());
    f.unpack(buffer.data());
    // ...
}
```
